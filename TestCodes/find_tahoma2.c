/*
 * Raw code to find the Tahoma on the network
 * This version stop as soon as one is found.
 *
 * Compilation
 * gcc find_tahoma.c -o find_tahoma $(pkg-config --cflags --libs avahi-client)
 *
 * Mostly generated by Gemini for testing purposes.
 * I didn't optimise anything and even kept the original comments.
 * It compiles, it runs as expected, no more.
 *
 * Provided under GPLv3
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include <avahi-client/client.h>
#include <avahi-client/lookup.h>
#include <avahi-common/simple-watch.h>
#include <avahi-common/error.h>
#include <avahi-common/defs.h>

// The service type we are looking for
#define SERVICE_TYPE "_kizboxdev._tcp"

static AvahiSimplePoll *simple_poll = NULL;
static AvahiServiceBrowser *browser = NULL;

/**
 * @brief Service Resolver Callback.
 * @details Called when detailed service information (address, port) is available.
 */
static void resolve_callback(
    AvahiServiceResolver *r,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    AvahiResolverEvent event,
    const char *name,
    const char *type,
    const char *domain,
    const char *host_name,
    const AvahiAddress *address,
    uint16_t port,
    AvahiStringList *txt,
    AvahiLookupResultFlags flags,
    void *userdata)
{
    assert(r);

    switch (event) {
        case AVAHI_RESOLVER_FAILURE:
            // Handle resolution failure
            fprintf(stderr, "(Resolver) Failed to resolve service '%s': %s\n", 
                        name, avahi_strerror(avahi_client_errno((AvahiClient*)userdata)));
            break;

        case AVAHI_RESOLVER_FOUND: {
            char a[AVAHI_ADDRESS_STR_MAX];
            // Convert AvahiAddress to human-readable string
            avahi_address_snprint(a, sizeof(a), address);

            printf("\n‚ú® **Service '%s' found and resolved:**\n", name);
            printf("  Type: %s, Domain: %s\n", type, domain);
            printf("  Host: **%s**, Address: **%s**, Port: **%u**\n", host_name, a, port);
            // TXT records could be processed here

            // --- MODIFICATION TO STOP THE MAIN LOOP ---
            if (simple_poll) {
                printf("\n--- First resolved service found. Stopping the main loop. ---\n");
                avahi_simple_poll_quit(simple_poll);
            }
            break;
        }
    }

    avahi_service_resolver_free(r); // Free the resolver after use
}

// ---

/**
 * @brief Service Browser Callback.
 * @details Called when a service is added or removed from the network.
 */
static void browse_callback(
    AvahiServiceBrowser *b,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    AvahiBrowserEvent event,
    const char *name,
    const char *type,
    const char *domain,
    AvahiLookupResultFlags flags,
    void* userdata)
{
    AvahiClient *c = userdata;
    assert(b);

    switch (event) {
        case AVAHI_BROWSER_FAILURE:
            // Handle browser failure
            fprintf(stderr, "(Browser) Failure: %s\n", avahi_strerror(avahi_client_errno(c)));
            avahi_simple_poll_quit(simple_poll);
            break;

        case AVAHI_BROWSER_NEW:
            printf("\nüîç **New service found:** '%s' of type '%s' in domain '%s'\n", name, type, domain);
            
            // Start resolution to get address and port
            if (!(avahi_service_resolver_new(c, interface, protocol, name, type, domain, AVAHI_PROTO_UNSPEC, 0, resolve_callback, c))) {
                fprintf(stderr, "Failed to create resolver for '%s': %s\n", name, avahi_strerror(avahi_client_errno(c)));
            }
            break;

        case AVAHI_BROWSER_REMOVE:
            printf("\n‚ùå **Service removed:** '%s' of type '%s' in domain '%s'\n", name, type, domain);
            break;

        case AVAHI_BROWSER_ALL_FOR_NOW:
            printf("\n(Browser) Initial browsing complete. Waiting for new services...\n");
            break;

        case AVAHI_BROWSER_CACHE_EXHAUSTED:
            printf("\n(Browser) Cache exhausted (initial pass complete or error)... Waiting for new services...\n");
            break;
    }
}

// ---

/**
 * @brief Avahi Client State Callback.
 * @details Called when the connection state to the Avahi daemon changes.
 */
static void client_callback(AvahiClient *c, AvahiClientState state, AVAHI_GCC_UNUSED void * userdata) {
    assert(c);

    switch (state) {
        case AVAHI_CLIENT_S_RUNNING:
            // Connection established, start service browsing
            printf("‚úÖ Connection to Avahi daemon established. Starting search for type **%s**...\n", SERVICE_TYPE);
            
            // Create a new service browser instance
            if (!(browser = avahi_service_browser_new(c, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, SERVICE_TYPE, "local", 0, browse_callback, c))) {
                fprintf(stderr, "Failed to create service browser: %s\n", avahi_strerror(avahi_client_errno(c)));
                avahi_simple_poll_quit(simple_poll);
            }
            break;

        case AVAHI_CLIENT_FAILURE:
            fprintf(stderr, "‚ùå Connection to Avahi server failed: %s\n", avahi_strerror(avahi_client_errno(c)));
            avahi_simple_poll_quit(simple_poll);
            break;
            
        case AVAHI_CLIENT_S_REGISTERING:
        case AVAHI_CLIENT_S_COLLISION:
        case AVAHI_CLIENT_CONNECTING:
            // Other states, do nothing for simple browsing
            break;
    }
}

// ---

int main(AVAHI_GCC_UNUSED int argc, AVAHI_GCC_UNUSED char*argv[]) {
    AvahiClient *client = NULL;
    int error;
    int ret = 1;

    // 1. Allocate the simple event loop object
    if (!(simple_poll = avahi_simple_poll_new())) {
        fprintf(stderr, "Failed to allocate avahi_simple_poll_new()\n");
        goto fail;
    }

    // 2. Create the Avahi client
    client = avahi_client_new(avahi_simple_poll_get(simple_poll), 0, client_callback, NULL, &error);

    // Check for client creation error
    if (!client) {
        fprintf(stderr, "Failed to create Avahi client: %s\n", avahi_strerror(error));
        goto fail;
    }

    // 3. Run the main loop
    printf("Starting Avahi client. Will exit after the first service is resolved.\n");
    avahi_simple_poll_loop(simple_poll);

    ret = 0;

fail:
    // 4. Cleanup
    if (browser)
        avahi_service_browser_free(browser);

    if (client)
        avahi_client_free(client);

    if (simple_poll)
        avahi_simple_poll_free(simple_poll);

    return ret;
}
